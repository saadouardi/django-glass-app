from fastapi import FastAPI, Query, HTTPException
from fastapi.middleware.cors import CORSMiddleware # type: ignore
from sqlite3 import connect

app = FastAPI()

origins = ["http://localhost:5173", "http://localhost:8000"]
app.add_middleware(CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d

@app.get("/data")
async def read_root(
    search: str = Query(default=None), page: int = Query(default=1), page_size: int = Query(default=10)
):
    """
    Fetch paginated data with optional search filtering from the database.

    Parameters:
    - search (str): Optional. A search string to filter images by title or description.
    - page (int): Optional. The current page number in pagination.
    - page_size (int): Optional. The number of records to return per page.

    Returns:
    - dict: A dictionary with two keys: 'images' which is a list of dictionaries containing image data,
            and 'total' which is an integer representing the total number of images that match the search criteria.
    """
    try:
        conn = connect("image_data.db")
        conn.row_factory = dict_factory
        cur = conn.cursor()

        # Query for total count
        if search:
            total_query = "SELECT COUNT(*) as total FROM image_data WHERE title LIKE ? OR description LIKE ?"
            total_result = cur.execute(total_query, [f"%{search}%", f"%{search}%"]).fetchone()
        else:
            total_query = "SELECT COUNT(*) as total FROM image_data"
            total_result = cur.execute(total_query).fetchone()

        total = total_result["total"]

        # Query for paginated results
        query = "SELECT * FROM image_data "
        params = []
        if search:
            query += "WHERE title LIKE ? OR description LIKE ? "
            params = [f"%{search}%", f"%{search}%"]
        query += "LIMIT ? OFFSET ?"
        params.extend([page_size, (page - 1) * page_size])
        cur.execute(query, params)

        images = cur.fetchall()
        return {"images": images, "total": total}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal Server Error: {str(e)}")


@app.put("/update/{image_id}")
async def update_image(image_id: str, image: dict):
    """
    Update an image's information.
    - **image_id**: The unique identifier for the image.
    - **image**: A dictionary containing image fields to update.
    """
    conn = connect("image_data.db")
    cur = conn.cursor()
    cur.execute("""
        UPDATE image_data SET title = ?, description = ?, ispublic = ?
        WHERE id = ?
    """, (image['title'], image['description'], image['ispublic'], image_id))
    if cur.rowcount == 0:
        raise HTTPException(status_code=404, detail="Image not found")
    conn.commit()
    return {"message": "Image updated successfully"}

# move search and filtering to the backend ✅
# move pagination logic to the backend ✅
# add error handling for the backend ✅
# minimize the code used in the frontend ✅
# add unit tests using pytest (test / integration tests) ✅
# add integration test using pytest (library in python) and requests (library in python) (in big projects) ✅
# add unit test comments: giving when then ✅
# add function comments() ✅